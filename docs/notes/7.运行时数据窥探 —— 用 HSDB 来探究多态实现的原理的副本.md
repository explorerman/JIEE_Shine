这篇文章我们将介绍如何通过 HSDB 工具来窥探 JVM 运行时数据，并通过 vtable 来深入理解对象继承和多态的原理。

## 0x01 HSDB 基础

HSDB 全称是：Hotspot Debugger，是内置的 JVM 工具，可以用来深入分析 JVM 运行时的内部状态。HSDB 位于 JDK 安装目录下的 lib/sa-jdi.jar 中， 启动 HSDB

```
sudo java -cp sa-jdi.jar sun.jvm.hotspot.HSDB

```

不出意外就会弹出下面的界面，在 File 菜单中可以选择 attach 到一个 Hotspot JVM 进程、或者打开一个 core 文件、或者连接到一个远程的 debug server。

![](https://user-gold-cdn.xitu.io/2019/6/1/16b1344961204064?w=1796&h=482&f=jpeg&s=87937)

attach 到一个 JVM 进程是最常用的选项，进程号的获取可以用系统自带的 ps 命令，也可以用 jps 命令。

在弹出的输入框中输入进程号以后默认展示当前线程列表。

![](https://user-gold-cdn.xitu.io/2019/6/1/16b137a152121a8f?w=906&h=928&f=jpeg&s=72006)

Tools 选项中有很多功能可供我们选择，比如查看类列表、查看堆信息、inspect 对象内存、死锁检测等，每个都值得好好玩一下。

![](https://user-gold-cdn.xitu.io/2019/6/1/16b137a158e56fe0?w=1262&h=838&f=jpeg&s=309659)

## 0x02 利用 HSDB 来看多态的基础 vtable

示例代码如下

```
public abstract class A {
    public void printMe() {
        System.out.println("I love vim");
    }
    public abstract void sayHello();
}
public class B extends A {
    @Override
    public void sayHello() {
        System.out.println("hello, i am child B");
    }
}

public class MyTest {
    public static void main(String[] args) throws IOException {
        A obj = new B();
        System.in.read();
        System.out.println(obj);
    }
}

```

运行 MyTest，在命令行中执行 jps，找到 MyTest 的进程 ID 97169

```
jps
97169 MyTest

```

在 HSDB 的界面中选择`File->Attach to Hotspot process`，输入进程号，然后选择`Tools->Class Browser`可以找到对象列表，找到 B 对象的内存指针地址。

```
B @0x00000007c0060418

```

然后选择`Tools->Inspector`输入 B 的上面的内存指针地址：

![](https://user-gold-cdn.xitu.io/2019/6/1/16b1344960253f96?w=930&h=896&f=jpeg&s=298681)

可以看到它的 vtable 的长度为 7。先说结论：有 5 个是 上帝类 Object 的 5 个方法，一个是 B 覆写的 sayHello 方法，一个是继承 A 的 printMe 方法，接下来我们来验证。

vtable 分配在 instanceKlass 对象实例的内存末尾，instanceKlass大小在 64 位系统的大小为 0x1b8，因此 vtable 的起始地址等于 instanceKlass 的内存首地址加上 0x1B8 等于 0x00000007C00605D0

```
0x00000007c0060418 + 0x1B8 = 0x00000007C00605D0

```

在 HSDB 的 console 输入 mem 查看实际的内存分布。mem 命令接受的两个参数都必选，一个是起始地址，另一个是长度。 输入`mem 0x7C00605D0 7`就可以查看 vtable 内存起始地址的 7 个方法指针地址了。

![](https://user-gold-cdn.xitu.io/2019/6/1/16b134495a37a04a?w=1622&h=754&f=jpeg&s=489272)

可以看到 vtable 的前 5 条一一对应 java.lang.Object 的五个方法，vtable 里存储的是指向方法内存的指针

```
void finalize()
boolean equals(java.lang.Object) 
java.lang.String toString()
int hashCode()
java.lang.Object clone()

```

我们继续看剩下的两个函数地址

![](https://user-gold-cdn.xitu.io/2019/6/1/16b1344961ed2bb2?w=1720&h=532&f=jpeg&s=252988)

可以看到 B 类的有一个函数是指向 A 类的方法 printMe。因为 B 继承 A 的 printMe 方法

最后一个函数 0x0000000104a80900 指向是 B 类的 sayHello,

![](https://user-gold-cdn.xitu.io/2019/6/1/16b13449680a4332?w=1692&h=498&f=jpeg&s=223067)

B 类 vtable 如下图所示

![](https://user-gold-cdn.xitu.io/2019/6/1/16b13947939be64f?w=1470&h=758&f=jpeg&s=219262)

vtable 是 Java 实现多态的基石，如果一个方法被继承和重写，会把 vtable 中指向父类的方法指针指向子类自己的实现。

*   Java 子类会继承父类的 vtable。Java 所有的类都会继承 java.lang.Object 类，Object 类有 5 个虚方法可以被继承和重写。当一个类不包含任何方法时，vtable 的长度也最小为 5，表示 Object 类的 5 个虚方法
*   final 和 static 修饰的方法不会被放到 vtable 方法表里
*   当子类重写了父类方法，子类 vtable 原本指向父类的方法指针会被替换为子类的方法指针
*   子类的 vtable 保持了父类的 vtable 的顺序

下面我们在做一些实验，让 B 实现接口 MyInterface，同时在 B 中新增了一个 static 方法和一个 final 方法。

```
public interface MyInterface {
    public void testMe();
}
public abstract class A {
    public void printMe() {
        System.out.println("I am vim fun");
    }
    public abstract void sayHello();
}
public class B extends A implements MyInterface {
    @Override
    public void sayHello() {
        System.out.println("hello, i am child B");
    }
    @Override
    public void testMe() {
        System.out.println("test me");
    }
    public static void foo(){
    }
    public final void testFinal() {
    }
}

```

采用同样的方法，这时显示 B 类的 vtable 大小为 8，这 8 个方法的指针地址用 mem 指令可以进行查看

![](https://user-gold-cdn.xitu.io/2019/6/1/16b13449a4a2dc64?w=1802&h=1160&f=jpeg&s=552807)

可以看到 vtable 中 B 类的 static 和 final 的方法没有出现。

![](https://user-gold-cdn.xitu.io/2019/6/1/16b13449a4f6c809?w=1470&h=674&f=jpeg&s=222965)

## 0x03 小结

作为上一篇文章的补充，这篇文章通过介绍 HSDB 工具来窥探 JVM 内存，通过 vtable 的例子深入理解了方法继承的细节以及多态的原理，当然还有很多有趣的事情可以用 HSDB 神器去发现，希望大家都可以熟练掌握这个工具。

## 参考文章

*   笨神的文章：[http://lovestblog.cn/blog/2014/06/28/hsdb-string/](http://lovestblog.cn/blog/2014/06/28/hsdb-string/)
*   R 大的文章：[https://rednaxelafx.iteye.com/blog/1847971](https://rednaxelafx.iteye.com/blog/1847971)